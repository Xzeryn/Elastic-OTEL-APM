/**
 * =============================================================================
 * PROCUREMENT DEMO APM TRAFFIC SIMULATOR
 * =============================================================================
 * 
 * This Playwright-based simulator generates real user traffic to the Procurement
 * Demo application, which in turn generates:
 *   - Elastic RUM traces (frontend user interactions)
 *   - Distributed traces through the backend services (Node.js, Python, Java)
 *   - Database queries (PostgreSQL)
 *   - Cache operations (Redis)
 * 
 * CONFIGURATION (via environment variables):
 *   BASE_URL          - Target application URL (default: https://demo.myhousetech.net)
 *   ACTION_DELAY      - Delay between actions in ms (default: 2000)
 *   CYCLE_DELAY       - Delay between full cycles in ms (default: 5000)
 *   ENABLE_UPLOADS    - Enable document uploads (default: true)
 *   UPLOAD_FREQUENCY  - Upload every N cycles (default: 5)
 *   HEADLESS          - Run browser headless (default: true)
 *   MAX_CYCLES        - Maximum cycles to run, 0 = infinite (default: 0)
 *   VERBOSE           - Enable verbose logging (default: false)
 * 
 * USAGE:
 *   npm start                           # Run with defaults
 *   ENABLE_UPLOADS=false npm start      # Disable uploads
 *   UPLOAD_FREQUENCY=10 npm start       # Upload every 10 cycles
 *   HEADLESS=false npm start            # Show browser window
 *   MAX_CYCLES=5 npm start              # Run 5 cycles then stop
 * 
 * =============================================================================
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');

// =============================================================================
// CONFIGURATION
// =============================================================================

const config = {
  baseUrl: process.env.BASE_URL || 'https://demo.myhousetech.net',
  actionDelay: parseInt(process.env.ACTION_DELAY || '2000', 10),
  cycleDelay: parseInt(process.env.CYCLE_DELAY || '5000', 10),
  enableUploads: process.env.ENABLE_UPLOADS !== 'false',
  uploadFrequency: parseInt(process.env.UPLOAD_FREQUENCY || '5', 10),
  headless: process.env.HEADLESS !== 'false',
  maxCycles: parseInt(process.env.MAX_CYCLES || '0', 10),
  verbose: process.env.VERBOSE === 'true'
};

// =============================================================================
// LOGGING
// =============================================================================

const log = {
  info: (msg) => console.log(`[${new Date().toISOString()}] INFO: ${msg}`),
  action: (msg) => console.log(`[${new Date().toISOString()}] ACTION: ${msg}`),
  verbose: (msg) => config.verbose && console.log(`[${new Date().toISOString()}] DEBUG: ${msg}`),
  error: (msg) => console.error(`[${new Date().toISOString()}] ERROR: ${msg}`),
  cycle: (num) => console.log(`\n${'='.repeat(60)}\n[${new Date().toISOString()}] CYCLE ${num}\n${'='.repeat(60)}`)
};

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const randomDelay = (baseMs, variance = 0.3) => {
  const min = baseMs * (1 - variance);
  const max = baseMs * (1 + variance);
  return Math.floor(Math.random() * (max - min) + min);
};

const randomElement = (arr) => arr[Math.floor(Math.random() * arr.length)];

/**
 * Create a temporary test file for upload simulation
 */
const createTestFile = () => {
  const testDir = path.join(__dirname, 'test-files');
  if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir, { recursive: true });
  }
  
  const filename = `test-document-${Date.now()}.txt`;
  const filepath = path.join(testDir, filename);
  const content = `
Procurement Test Document
Generated: ${new Date().toISOString()}
Simulator: procurement-simulator v1.0.0

This is a test document generated by the APM traffic simulator.
It is used to test the document upload functionality and generate
distributed traces through the system.

Random data: ${Math.random().toString(36).substring(2, 15)}
`;
  
  fs.writeFileSync(filepath, content);
  return filepath;
};

/**
 * Clean up test files older than 1 hour
 */
const cleanupTestFiles = () => {
  const testDir = path.join(__dirname, 'test-files');
  if (!fs.existsSync(testDir)) return;
  
  const files = fs.readdirSync(testDir);
  const oneHourAgo = Date.now() - (60 * 60 * 1000);
  
  files.forEach(file => {
    const filepath = path.join(testDir, file);
    const stats = fs.statSync(filepath);
    if (stats.mtimeMs < oneHourAgo) {
      fs.unlinkSync(filepath);
      log.verbose(`Cleaned up old test file: ${file}`);
    }
  });
};

// =============================================================================
// SIMULATION ACTIONS
// =============================================================================

/**
 * Navigate to a page and wait for it to load
 */
async function navigateTo(page, path, name) {
  log.action(`Navigating to ${name} (${path})`);
  await page.goto(`${config.baseUrl}${path}`, { waitUntil: 'networkidle' });
  await delay(randomDelay(config.actionDelay));
}

/**
 * Simulate viewing the dashboard
 */
async function viewDashboard(page) {
  await navigateTo(page, '/', 'Dashboard');
  
  // Click refresh button if visible
  try {
    const refreshButton = page.locator('[data-transaction-name="Refresh Dashboard"]');
    if (await refreshButton.isVisible({ timeout: 2000 })) {
      log.action('Clicking Refresh Dashboard');
      await refreshButton.click();
      await delay(randomDelay(config.actionDelay));
    }
  } catch (e) {
    log.verbose('Refresh button not found or not clickable');
  }
}

/**
 * Simulate viewing invoices
 */
async function viewInvoices(page) {
  await navigateTo(page, '/invoices', 'Invoices');
  
  // Try to click on an invoice row if available
  try {
    const invoiceRows = page.locator('table tbody tr');
    const count = await invoiceRows.count();
    if (count > 0) {
      const randomIndex = Math.floor(Math.random() * Math.min(count, 5));
      log.action(`Clicking invoice row ${randomIndex + 1}`);
      await invoiceRows.nth(randomIndex).click();
      await delay(randomDelay(config.actionDelay));
    }
  } catch (e) {
    log.verbose('No invoice rows to interact with');
  }
}

/**
 * Simulate viewing documents
 */
async function viewDocuments(page) {
  await navigateTo(page, '/documents', 'Documents');
  
  // Look at document list
  try {
    const docRows = page.locator('table tbody tr');
    const count = await docRows.count();
    log.verbose(`Found ${count} documents in list`);
  } catch (e) {
    log.verbose('No document table found');
  }
}

/**
 * Simulate uploading a document
 */
async function uploadDocument(page) {
  await navigateTo(page, '/documents', 'Documents');
  
  log.action('Starting document upload simulation');
  
  try {
    // Create a test file
    const testFilePath = createTestFile();
    log.verbose(`Created test file: ${testFilePath}`);
    
    // Find the file input
    const fileInput = page.locator('input[type="file"]');
    if (await fileInput.count() > 0) {
      // Upload the file
      await fileInput.setInputFiles(testFilePath);
      log.action('File selected for upload');
      await delay(randomDelay(1000));
      
      // Click upload button
      const uploadButton = page.locator('[data-transaction-name="Upload Document"]');
      if (await uploadButton.isVisible({ timeout: 2000 })) {
        await uploadButton.click();
        log.action('Clicked Upload Document button');
        await delay(randomDelay(config.actionDelay * 2)); // Wait longer for upload
      }
    } else {
      log.verbose('File input not found');
    }
    
    // Clean up old test files
    cleanupTestFiles();
    
  } catch (e) {
    log.error(`Upload simulation failed: ${e.message}`);
  }
}

/**
 * Simulate viewing payments
 */
async function viewPayments(page) {
  await navigateTo(page, '/payments', 'Payments');
  
  // Look at payment list
  try {
    const paymentRows = page.locator('table tbody tr');
    const count = await paymentRows.count();
    log.verbose(`Found ${count} payments in list`);
  } catch (e) {
    log.verbose('No payment table found');
  }
}

/**
 * Simulate processing a payment
 */
async function processPayment(page) {
  await navigateTo(page, '/payments', 'Payments');
  
  log.action('Attempting to process a payment');
  
  try {
    // Look for process payment button
    const processButton = page.locator('[data-transaction-name="Process Payment"]');
    if (await processButton.isVisible({ timeout: 2000 })) {
      await processButton.click();
      log.action('Clicked Process Payment button');
      await delay(randomDelay(config.actionDelay * 1.5));
    } else {
      // Try finding any "Process" button
      const anyProcessButton = page.locator('button:has-text("Process")').first();
      if (await anyProcessButton.isVisible({ timeout: 2000 })) {
        await anyProcessButton.click();
        log.action('Clicked Process button');
        await delay(randomDelay(config.actionDelay * 1.5));
      }
    }
  } catch (e) {
    log.verbose(`Payment processing not available: ${e.message}`);
  }
}

/**
 * Simulate viewing vendors
 */
async function viewVendors(page) {
  await navigateTo(page, '/vendors', 'Vendors');
  
  // Try to click on a vendor row if available
  try {
    const vendorRows = page.locator('table tbody tr');
    const count = await vendorRows.count();
    if (count > 0) {
      const randomIndex = Math.floor(Math.random() * Math.min(count, 5));
      log.action(`Clicking vendor row ${randomIndex + 1}`);
      await vendorRows.nth(randomIndex).click();
      await delay(randomDelay(config.actionDelay));
    }
  } catch (e) {
    log.verbose('No vendor rows to interact with');
  }
}

/**
 * View the architecture modal
 */
async function viewArchitectureModal(page) {
  await navigateTo(page, '/', 'Dashboard');
  
  log.action('Opening architecture diagram modal');
  
  try {
    // Click on the version text in the footer
    const versionText = page.locator('text=Procurement System v1.0.0');
    if (await versionText.isVisible({ timeout: 2000 })) {
      await versionText.click();
      await delay(randomDelay(config.actionDelay));
      
      // Close the modal
      const closeButton = page.locator('.modal-close, [aria-label="Close"], button:has-text("Ã—")').first();
      if (await closeButton.isVisible({ timeout: 2000 })) {
        await closeButton.click();
        log.action('Closed architecture modal');
        await delay(randomDelay(1000));
      }
    }
  } catch (e) {
    log.verbose('Architecture modal not available');
  }
}

// =============================================================================
// MAIN SIMULATION LOOP
// =============================================================================

async function runSimulation() {
  log.info('Starting Procurement Demo APM Traffic Simulator');
  log.info(`Configuration:`);
  log.info(`  Base URL: ${config.baseUrl}`);
  log.info(`  Action Delay: ${config.actionDelay}ms`);
  log.info(`  Cycle Delay: ${config.cycleDelay}ms`);
  log.info(`  Uploads Enabled: ${config.enableUploads}`);
  log.info(`  Upload Frequency: Every ${config.uploadFrequency} cycles`);
  log.info(`  Headless: ${config.headless}`);
  log.info(`  Max Cycles: ${config.maxCycles === 0 ? 'Infinite' : config.maxCycles}`);
  
  const browser = await chromium.launch({
    headless: config.headless
  });
  
  const context = await browser.newContext({
    viewport: { width: 1280, height: 800 },
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 ProcurementSimulator/1.0'
  });
  
  const page = await context.newPage();
  
  // Log console messages from the page
  page.on('console', msg => {
    if (config.verbose && msg.type() === 'error') {
      log.verbose(`Browser console error: ${msg.text()}`);
    }
  });
  
  let cycleCount = 0;
  
  try {
    // Initial page load
    log.info('Performing initial page load...');
    await page.goto(config.baseUrl, { waitUntil: 'networkidle' });
    await delay(config.actionDelay);
    
    // Main simulation loop
    while (config.maxCycles === 0 || cycleCount < config.maxCycles) {
      cycleCount++;
      log.cycle(cycleCount);
      
      // Standard navigation cycle
      const actions = [
        () => viewDashboard(page),
        () => viewInvoices(page),
        () => viewDocuments(page),
        () => viewPayments(page),
        () => viewVendors(page),
        () => processPayment(page),
        () => viewArchitectureModal(page)
      ];
      
      // Shuffle actions for variety
      const shuffledActions = actions.sort(() => Math.random() - 0.5);
      
      // Execute actions
      for (const action of shuffledActions) {
        try {
          await action();
        } catch (e) {
          log.error(`Action failed: ${e.message}`);
        }
      }
      
      // Upload document based on frequency
      if (config.enableUploads && cycleCount % config.uploadFrequency === 0) {
        log.info(`Upload cycle (every ${config.uploadFrequency} cycles)`);
        try {
          await uploadDocument(page);
        } catch (e) {
          log.error(`Upload failed: ${e.message}`);
        }
      }
      
      // Wait between cycles
      log.info(`Cycle ${cycleCount} complete. Waiting ${config.cycleDelay}ms before next cycle...`);
      await delay(config.cycleDelay);
    }
    
    log.info(`Completed ${cycleCount} cycles. Shutting down...`);
    
  } catch (e) {
    log.error(`Simulation error: ${e.message}`);
    throw e;
  } finally {
    await browser.close();
    log.info('Browser closed. Simulation ended.');
  }
}

// =============================================================================
// ENTRY POINT
// =============================================================================

// Handle graceful shutdown
process.on('SIGINT', () => {
  log.info('Received SIGINT. Shutting down gracefully...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  log.info('Received SIGTERM. Shutting down gracefully...');
  process.exit(0);
});

// Run the simulation
runSimulation().catch(e => {
  log.error(`Fatal error: ${e.message}`);
  process.exit(1);
});
